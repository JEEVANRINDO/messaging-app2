<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=resizes-content">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' blob: data:; script-src 'self' 'unsafe-inline' https://cdn.tailwindcss.com https://unpkg.com https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src https://fonts.gstatic.com; connect-src *;">
    <title>GhostMesh | Pro Secure</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>

    <style>
        /* ... (CSS remains the same) ... */
    </style>
</head>
<body class="flex flex-col md:flex-row">

    <!-- ... (HTML structure remains the same) ... -->

    <script>
        const Utils = {
            escapeHTML: str => str.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m]),
            linkify: str => str.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" class="text-blue-400 hover:underline">$1</a>'),
            blobRegistry: new Map(), // Changed from Set to Map for better tracking
            addBlob: (key, url) => { 
                // Revoke old URL if exists
                if (Utils.blobRegistry.has(key)) {
                    URL.revokeObjectURL(Utils.blobRegistry.get(key));
                }
                Utils.blobRegistry.set(key, url); 
                return url; 
            },
            revokeBlobs: () => { 
                Utils.blobRegistry.forEach(u => URL.revokeObjectURL(u)); 
                Utils.blobRegistry.clear(); 
            },
            bufferToHex: (buf) => Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2,'0')).join(''),
            formatBytes: (bytes) => {
                if (bytes === 0) return '0 B';
                const k=1024, i=Math.floor(Math.log(bytes)/Math.log(k));
                return parseFloat((bytes/Math.pow(k,i)).toFixed(1)) + ' ' + ['B','KB','MB','GB'][i];
            },
            detectMimeType: (fileName, mimeType) => {
                // If mime type is valid, use it
                if (mimeType && mimeType.trim() && mimeType !== 'application/octet-stream') return mimeType;
                
                // Fallback to extension-based detection
                if (!fileName) return 'application/octet-stream';
                const ext = fileName.toLowerCase().split('.').pop();
                const mimeMap = {
                    'jpg': 'image/jpeg', 'jpeg': 'image/jpeg', 'png': 'image/png', 'gif': 'image/gif',
                    'webp': 'image/webp', 'heic': 'image/heic', 'heif': 'image/heif',
                    'mp4': 'video/mp4', 'webm': 'video/webm', 'mov': 'video/quicktime',
                    'pdf': 'application/pdf', 'doc': 'application/msword', 'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                    'xls': 'application/vnd.ms-excel', 'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                    'ppt': 'application/vnd.ms-powerpoint', 'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
                    'zip': 'application/zip', 'rar': 'application/x-rar-compressed', '7z': 'application/x-7z-compressed',
                    'mp3': 'audio/mpeg', 'wav': 'audio/wav', 'ogg': 'audio/ogg', 'm4a': 'audio/mp4'
                };
                return mimeMap[ext] || 'application/octet-stream';
            },
            getStatusHtml: (status) => {
                let cl = 'status-orb';
                if(status === 'pending') cl += ' status-pending';
                else if(status === 'sent') cl += ' status-sent';
                else if(status === 'delivered') cl += ' status-delivered';
                else if(status === 'read') cl += ' status-read';
                return `<div class="status-container"><div class="${cl}"></div></div>`;
            },
            getFileIcon: (mime, name) => {
                if (!name || typeof name !== 'string') return '<div class="file-icon-box" style="background-color: #8696a0">FILE</div>';
                const parts = name.split('.');
                const ext = parts.length > 1 ? parts.pop().toUpperCase() : 'FILE';
                let color = '#8696a0'; // default gray
                let label = ext.substring(0, 3);
                
                if (mime && mime.includes('pdf')) { color = '#ef4444'; label = 'PDF'; }
                else if (mime && (mime.includes('word') || ext === 'DOC' || ext === 'DOCX')) { color = '#3b82f6'; label = 'DOC'; }
                else if (mime && (mime.includes('zip') || ext === 'ZIP' || ext === 'RAR')) { color = '#f97316'; label = 'ZIP'; }
                else if (mime && (mime.includes('excel') || ext === 'XLS' || ext === 'XLSX')) { color = '#10b981'; label = 'XLS'; }
                else if (mime && (mime.includes('powerpoint') || ext === 'PPT' || ext === 'PPTX')) { color = '#f59e0b'; label = 'PPT'; }
                
                return `<div class="file-icon-box" style="background-color: ${color}">${label}</div>`;
            },
            // NEW: Check if file is an image by mime type or extension
            isImageFile: (fileName, mimeType) => {
                const mime = Utils.detectMimeType(fileName, mimeType);
                if (mime.startsWith('image/')) return true;
                
                // Also check by extension
                if (!fileName) return false;
                const ext = fileName.toLowerCase().split('.').pop();
                const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'heic', 'heif', 'bmp', 'svg'];
                return imageExtensions.includes(ext);
            }
        };

        const Store = {
            // ... (Store code remains the same) ...
        };

        const Crypto = {
            // ... (Crypto code remains the same) ...
        };

        const Network = {
            CONFIG: { CONNECTION_TIMEOUT: 15000, RECONNECT_INTERVAL: 30000, RECONNECT_DELAY: 3000, PEER_READY_RETRY_DELAY: 2000, PING_INTERVAL: 5000, MAX_RETRY_ATTEMPTS: 3, INITIAL_BACKOFF: 1000, DEBUG_MODE: false },
            peer: null, connections: {}, uploadCancelled: false, typingTimers: {}, connectionStates: {}, pingIntervalId: null, reconnectIntervalId: null,
            debugLog: (message, data) => {
                if (Network.CONFIG.DEBUG_MODE) {
                    console.log(`[${new Date().toISOString()}] ${message}`, data || '');
                    const debugLogs = document.getElementById('debug-logs');
                    if (debugLogs) {
                        const logDiv = document.createElement('div');
                        logDiv.className = 'text-[#00a884]';
                        logDiv.textContent = `${message} ${data ? JSON.stringify(data) : ''}`;
                        debugLogs.prepend(logDiv);
                        while (debugLogs.children.length > 50) debugLogs.removeChild(debugLogs.lastChild);
                    }
                }
            },
            init: async (id) => {
                // ... (init code remains the same) ...
            },
            connectToInput: () => {
                // ... (connectToInput code remains the same) ...
            },
            connectWithRetry: async (id, retries = 0, backoff = Network.CONFIG.INITIAL_BACKOFF) => {
                // ... (connectWithRetry code remains the same) ...
            },
            handleConn: (conn) => {
                // ... (handleConn code remains the same) ...
            },
            processQueue: async (peerId) => {
                // ... (processQueue code remains the same) ...
            },
            handleData: async (sender, data, conn) => {
                if (data.type === 'handshake' || data.type === 'handshake-ack') {
                    try {
                        const pub = await Crypto.importKey(data.key);
                        const shared = await Crypto.deriveShared(pub);
                        const pubStr = btoa(String.fromCharCode(...new Uint8Array(await window.crypto.subtle.exportKey("spki", pub))));
                        
                        // FIX #4: Check if contact with same public key already exists
                        let existingPeerId = null;
                        for (const [pid, contact] of Object.entries(App.state.contacts)) {
                            if (contact.pubStr === pubStr) {
                                existingPeerId = pid;
                                break;
                            }
                        }
                        
                        if (existingPeerId && existingPeerId !== sender) {
                            // Same person, different peer ID - migrate to new ID
                            console.log(`Contact reconnected with new peer ID: ${existingPeerId} -> ${sender}`);
                            
                            // Migrate messages
                            const msgs = await Store.getMessages(existingPeerId);
                            for (const msg of msgs) {
                                msg.peerId = sender;
                                await Store.put('messages', null, msg);
                            }
                            
                            // Update active chat if needed
                            if (App.state.activeChat === existingPeerId) {
                                App.state.activeChat = sender;
                            }
                            
                            // Delete old contact entry
                            delete App.state.contacts[existingPeerId];
                            delete Network.connections[existingPeerId];
                            delete Network.connectionStates[existingPeerId];
                        }
                        
                        // Add or update contact
                        await App.addContact(sender, data.name, pubStr);
                        
                        // Update connection object
                        Network.connections[sender] = { 
                            conn, 
                            key: shared, 
                            seqOut: 0, 
                            lastSeq: 0, 
                            handshakeComplete: true 
                        };
                        Network.connectionStates[sender] = 'connected';
                        
                        if (data.type === 'handshake') conn.send({ type: 'handshake-ack', key: App.state.pubStr, name: App.state.name, id: App.state.id });
                        
                        // Process pending messages after handshake
                        await Network.processQueue(sender);
                        
                        if (App.state.activeChat === sender || !App.state.activeChat) UI.loadChat(sender);
                        UI.updateConnectionState(sender, 'connected');
                    } catch (err) { conn.close(); }
                    return;
                }
                
                const connObj = Network.connections[sender];
                if (!connObj || !connObj.key) return;

                if (data.type === 'receipt') {
                     const msgs = await Store.getMessages(sender);
                     const msg = msgs.find(m => m.id === data.msgId);
                     if (msg) {
                         const priority = { 'pending': 0, 'sent': 1, 'delivered': 2, 'read': 3 };
                         if (priority[data.status] > priority[msg.status || 'pending']) {
                             msg.status = data.status;
                             await Store.put('messages', null, msg);
                             if (App.state.activeChat === sender) UI.updateMessageTick(msg.id, data.status);
                         }
                     }
                     return;
                }
                
                if (data.type === 'typing') {
                    if (App.state.activeChat === sender) {
                        UI.showTypingIndicator(true);
                        clearTimeout(Network.typingTimers[sender]);
                        Network.typingTimers[sender] = setTimeout(() => UI.showTypingIndicator(false), 3000);
                    }
                    return;
                }
                
                if (data.type === 'reaction') {
                    await Store.putReaction({ id: `${data.msgId}-${sender}-${data.emoji}`, msgId: data.msgId, userId: sender, emoji: data.emoji, timestamp: Date.now() });
                    if (App.state.activeChat === sender) UI.updateReactions(data.msgId);
                    return;
                }
                
                if (data.type === 'unreact') {
                    await Store.deleteReaction(`${data.msgId}-${sender}-${data.emoji}`);
                    if (App.state.activeChat === sender) UI.updateReactions(data.msgId);
                    return;
                }
                
                if (data.type === 'ping') { if (connObj?.conn?.open) connObj.conn.send({ type: 'pong', ts: data.ts }); return; }
                if (data.type === 'pong') { if (connObj?.pingStart) connObj.ping = Date.now() - data.ts; return; }
                if (data.type === 'clear-chat') { await Store.deleteMessagesForPeer(sender); if (App.state.activeChat === sender) UI.loadChat(sender); return; }
                
                if (data.type === 'delete-for-everyone') {
                    const msgs = await Store.getMessages(sender);
                    const msg = msgs.find(m => m.id === data.msgId);
                    if (msg) {
                        msg.deletedForEveryone = true; msg.content = 'This message was deleted';
                        await Store.put('messages', null, msg);
                        if (App.state.activeChat === sender) UI.loadChat(sender);
                    }
                    return;
                }

                if (data.type === 'msg') {
                    try {
                        const dec = await Crypto.decryptPayload(data.payload, connObj.key);
                        if(dec.seq <= connObj.lastSeq) return;
                        connObj.lastSeq = dec.seq;

                        if(dec.type === 'text' || dec.type === 'location') {
                             const msgId = data.id || Date.now().toString();
                             const content = dec.type === 'location' ? { lat: dec.lat, lon: dec.lon, url: dec.url } : Utils.escapeHTML(dec.content);
                             App.addMessage(sender, content, 'in', dec.type, 'read', msgId);
                             setTimeout(() => {
                                 if (connObj?.conn?.open) {
                                     conn.send({ type: 'receipt', msgId: msgId, status: 'delivered' });
                                     if (App.state.activeChat === sender) conn.send({ type: 'receipt', msgId: msgId, status: 'read' });
                                 }
                             }, 50);
                        }
                    } catch(e) {}
                }
                
                if (data instanceof ArrayBuffer || data instanceof Uint8Array) {
                    const tracker = App.fileChunks[sender];
                    if (!tracker) return;
                    try {
                        const dec = await Crypto.decryptBin(data, connObj.key);
                        tracker.chunks.push(dec);
                        tracker.received += data.byteLength;
                        if (App.state.activeChat === sender) {
                            const pct = Math.min(100, Math.round((tracker.received / tracker.encSize) * 100));
                            document.getElementById('download-progress').classList.remove('hidden');
                            document.getElementById('dl-progress-bar').style.width = pct + "%";
                            document.getElementById('dl-progress-percent').innerText = pct + "%";
                        }
                        
                        if (tracker.received >= tracker.encSize) {
                            // Hide download progress
                            const downloadProgress = document.getElementById('download-progress');
                            if (downloadProgress) downloadProgress.classList.add('hidden');
                            
                            const blob = new Blob(tracker.chunks, { type: tracker.mime });
                            // FIX #2: Create URL once and store it with message
                            const urlKey = `file-${tracker.msgId}`;
                            const url = Utils.addBlob(urlKey, URL.createObjectURL(blob));
                            
                            // Create message data with URL
                            const msgData = {
                                id: tracker.msgId,
                                peerId: sender,
                                content: { 
                                    name: tracker.name, 
                                    blob: blob, 
                                    mime: tracker.mime, 
                                    size: blob.size, 
                                    url: url,
                                    urlKey: urlKey // Store the key for cleanup
                                },
                                direction: 'in',
                                type: tracker.mime.startsWith('audio') ? 'voice' : 'file',
                                status: 'read',
                                timestamp: Date.now()
                            };
                            
                            await Store.put('messages', null, msgData);
                            
                            if(App.state.activeChat === sender) {
                                UI.renderMessage(msgData);
                            }

                            if (connObj?.conn?.open) {
                                conn.send({ type: 'receipt', msgId: tracker.msgId, status: 'delivered' });
                                if(App.state.activeChat === sender) {
                                    conn.send({ type: 'receipt', msgId: tracker.msgId, status: 'read' });
                                }
                            }
                            delete App.fileChunks[sender];
                        }
                    } catch(e){ 
                        console.error('File download error:', e);
                        delete App.fileChunks[sender]; 
                    }
                }
                if (data.type === 'file-start') {
                     // FIX #1: Use enhanced mime type detection
                     const detectedMime = Utils.detectMimeType(data.name, data.mime);
                     App.fileChunks[sender] = { ...data, mime: detectedMime, received: 0, chunks: [], msgId: data.id };
                     
                     // Create placeholder message
                     App.addMessage(sender, { 
                         name: data.name, 
                         mime: detectedMime, 
                         size: data.size || 0, 
                         blob: null 
                     }, 'in', 'file', 'pending', data.id);
                }
            },
            cancelUpload: () => { Network.uploadCancelled = true; },
            sendMessage: async () => {
                if (!App.state.activeChat) return;
                const peerId = App.state.activeChat, input = document.getElementById('message-input'), fileInput = document.getElementById('file-input');
                const connObj = Network.connections[peerId];
                
                // FIX #3: Separate file and text sending (not else-if)
                let fileSent = false;
                
                if (fileInput.files.length > 0) {
                    fileSent = true;
                    const file = fileInput.files[0];
                    if (file.size > 50*1024*1024) { 
                        UI.showToast("File size must be under 50MB"); 
                        UI.clearFile(); 
                        return; 
                    }
                    if (!connObj?.conn?.open || !connObj?.key) { 
                        UI.showToast("Cannot send files while offline"); 
                        return; 
                    }

                    Network.uploadCancelled = false;
                    const CHUNK = 256 * 1024;
                    const overhead = 28;
                    const numChunks = Math.ceil(file.size / CHUNK);
                    const totalEncSize = file.size + (numChunks * overhead);
                    const msgId = Date.now().toString();
                    
                    // FIX #1: Use enhanced mime type detection
                    const detectedMime = Utils.detectMimeType(file.name, file.type);
                    
                    // FIX #2: Create ObjectURL once and store it
                    const urlKey = `file-${msgId}`;
                    const fileUrl = Utils.addBlob(urlKey, URL.createObjectURL(file));
                    
                    App.addMessage(peerId, { 
                        name: file.name, 
                        blob: file, 
                        mime: detectedMime, 
                        size: file.size, 
                        url: fileUrl,
                        urlKey: urlKey 
                    }, 'out', 'file', 'pending', msgId);
                    
                    // Clear file input
                    fileInput.value = '';
                    UI.clearFile();

                    connObj.conn.send({ 
                        type: 'file-start', 
                        id: msgId, 
                        name: file.name, 
                        mime: detectedMime, 
                        encSize: totalEncSize,
                        size: file.size 
                    });
                    
                    let offset = 0;
                    document.getElementById('upload-progress').classList.remove('hidden');
                    
                    const streamLoop = async () => {
                        if (Network.uploadCancelled) { 
                            document.getElementById('upload-progress').classList.add('hidden'); 
                            // Revoke the blob URL since upload was cancelled
                            if (fileUrl) URL.revokeObjectURL(fileUrl);
                            return; 
                        }
                        if(offset >= file.size) {
                             // File upload complete
                             document.getElementById('upload-progress').classList.add('hidden');
                             const msg = (await Store.getMessages(peerId)).find(m => m.id === msgId);
                             if(msg) { 
                                 msg.status = 'sent'; 
                                 await Store.put('messages', null, msg); 
                                 UI.updateMessageTick(msgId, 'sent'); 
                             }
                             // Don't toggle send icon here - let text handler do it
                             return;
                        }
                        if(connObj.conn.dataChannel.bufferedAmount > 32 * 1024 * 1024) { 
                            setTimeout(streamLoop, 50); 
                            return; 
                        }
                        const slice = file.slice(offset, offset + CHUNK);
                        const buf = await slice.arrayBuffer();
                        const enc = await Crypto.encryptBin(buf, connObj.key);
                        connObj.conn.send(enc);
                        offset += CHUNK;
                        const pct = Math.min(100, Math.round((offset/file.size)*100));
                        document.getElementById('progress-bar').style.width = pct + "%";
                        document.getElementById('progress-percent').innerText = pct + "%";
                        requestAnimationFrame(streamLoop);
                    };
                    streamLoop();
                }
                
                // FIX #3: Always check for text message (not else-if)
                if (input.value.trim()) {
                    const text = input.value.trim();
                    const msgId = Date.now().toString();
                    App.addMessage(peerId, text, 'out', 'text', 'pending', msgId);
                    input.value = '';
                    input.style.height = 'auto';
                    UI.toggleSendIcon();
                    await UI.clearDraft(peerId);
                    document.getElementById('smart-replies-container').classList.add('hidden');

                    if (connObj?.conn?.open && connObj.key && connObj.handshakeComplete) {
                        try {
                            const encPayload = await Crypto.encryptPayload({ 
                                content: text, 
                                seq: ++connObj.seqOut, 
                                ts: Date.now(), 
                                type: 'text' 
                            }, connObj.key);
                            connObj.conn.send({ type: 'msg', id: msgId, payload: encPayload });
                            const msg = (await Store.getMessages(peerId)).find(m => m.id === msgId);
                            if(msg) { 
                                msg.status = 'sent'; 
                                await Store.put('messages', null, msg); 
                                UI.updateMessageTick(msgId, 'sent'); 
                            }
                        } catch(e) {
                            console.error('Text send error:', e);
                        }
                    }
                } else if (!fileSent) {
                    // No file and no text - toggle send icon back to mic
                    UI.toggleSendIcon();
                }
            },
            sendTyping: () => { 
                if (App.state.activeChat && Network.connections[App.state.activeChat]?.conn?.open) 
                    Network.connections[App.state.activeChat].conn.send({ type: 'typing' }); 
            },
            sendReaction: async (msgId, emoji) => {
                if (App.state.activeChat && Network.connections[App.state.activeChat]?.conn?.open) {
                    Network.connections[App.state.activeChat].conn.send({ type: 'reaction', msgId, emoji });
                    await Store.putReaction({ id: `${msgId}-${App.state.id}-${emoji}`, msgId, userId: App.state.id, emoji, timestamp: Date.now() });
                    UI.updateReactions(msgId);
                }
            },
            removeReaction: async (msgId, emoji) => {
                if (App.state.activeChat && Network.connections[App.state.activeChat]?.conn?.open) {
                    Network.connections[App.state.activeChat].conn.send({ type: 'unreact', msgId, emoji });
                    await Store.deleteReaction(`${msgId}-${App.state.id}-${emoji}`);
                    UI.updateReactions(msgId);
                }
            },
            startPingMonitor: () => {
                if (Network.pingIntervalId) clearInterval(Network.pingIntervalId);
                if (Network.reconnectIntervalId) clearInterval(Network.reconnectIntervalId);
                Network.pingIntervalId = setInterval(() => { 
                    Object.keys(Network.connections).forEach(peerId => { 
                        const connObj = Network.connections[peerId]; 
                        if (connObj?.conn?.open && connObj.handshakeComplete) { 
                            connObj.pingStart = Date.now(); 
                            connObj.conn.send({ type: 'ping', ts: connObj.pingStart }); 
                        } 
                    }); 
                }, Network.CONFIG.PING_INTERVAL);
                Network.reconnectIntervalId = setInterval(() => { 
                    Object.keys(App.state.contacts).forEach(peerId => { 
                        const connObj = Network.connections[peerId]; 
                        if (!connObj || !connObj.conn || connObj.conn.disconnected) { 
                            Network.connectWithRetry(peerId, 0, 5000); 
                        } 
                    }); 
                }, Network.CONFIG.RECONNECT_INTERVAL);
            },
            stopPingMonitor: () => { 
                if (Network.pingIntervalId) clearInterval(Network.pingIntervalId); 
                if (Network.reconnectIntervalId) clearInterval(Network.reconnectIntervalId); 
            }
        };

        const App = {
            CONFIG: { MIN_NAME_LENGTH: 2, MAX_NAME_LENGTH: 50, MIN_PASSWORD_LENGTH: 4, MAX_PASSWORD_LENGTH: 100 },
            state: { 
                id: null, 
                name: null, 
                pubStr: null, 
                password: null, 
                activeChat: null, 
                contacts: {}, 
                loginAttempts: 0, 
                lockoutUntil: null, 
                lastSeen: {},
                pubStrToPeerId: {} // NEW: Map public key to current peer ID
            },
            fileChunks: {}, 
            notificationPermission: false,
            init: async () => {
                // ... (init code remains the same) ...
            },
            createProfile: async () => {
                // ... (createProfile code remains the same) ...
            },
            login: async () => {
                // ... (login code remains the same) ...
            },
            addContact: async (peerId, name, pubStr) => {
                if (!peerId || !name || !pubStr) return;
                const sanitizedName = name.trim().substring(0, App.CONFIG.MAX_NAME_LENGTH);
                
                // Store mapping of public key to peer ID
                App.state.pubStrToPeerId[pubStr] = peerId;
                
                // Check if we already have this contact (by public key)
                let existingPeerId = null;
                for (const [pid, contact] of Object.entries(App.state.contacts)) {
                    if (contact.pubStr === pubStr && pid !== peerId) {
                        existingPeerId = pid;
                        break;
                    }
                }
                
                if (existingPeerId) {
                    // Update existing contact with new peer ID
                    console.log(`Updating contact ${sanitizedName} from ${existingPeerId} to ${peerId}`);
                    
                    // Migrate messages if needed
                    const msgs = await Store.getMessages(existingPeerId);
                    if (msgs.length > 0) {
                        for (const msg of msgs) {
                            msg.peerId = peerId;
                            await Store.put('messages', null, msg);
                        }
                        console.log(`Migrated ${msgs.length} messages`);
                    }
                    
                    // Delete old contact
                    delete App.state.contacts[existingPeerId];
                    
                    // Update active chat if needed
                    if (App.state.activeChat === existingPeerId) {
                        App.state.activeChat = peerId;
                        setTimeout(() => UI.loadChat(peerId), 100);
                    }
                }
                
                // Add/update contact
                App.state.contacts[peerId] = { 
                    name: sanitizedName, 
                    pubStr, 
                    lastSeen: Date.now(),
                    originalName: name // Store original for reference
                };
                
                await Store.put('config', 'contacts', App.state.contacts);
                await Store.put('config', 'pubStrToPeerId', App.state.pubStrToPeerId);
                
                UI.renderContactList();
                
                // If this is the active chat, reload it
                if (App.state.activeChat === peerId) {
                    setTimeout(() => UI.loadChat(peerId), 100);
                }
            },
            addMessage: async (peerId, content, direction, type, status, id) => {
                const msgId = id || Date.now().toString();
                const msg = { 
                    id: msgId, 
                    peerId, 
                    content, 
                    direction, 
                    type, 
                    status: status || 'pending', 
                    timestamp: Date.now() 
                };
                
                await Store.put('messages', null, msg);
                
                if (App.state.contacts[peerId]) {
                    const preview = type === 'text' ? content.substring(0, 50) : 
                                  type === 'file' ? 'ðŸ“Ž File' : 
                                  type === 'voice' ? 'ðŸŽ¤ Voice' : 
                                  type === 'location' ? 'ðŸ“ Location' : 'Message';
                    App.state.contacts[peerId].lastMessage = preview;
                    
                    if (direction === 'in' && App.state.activeChat !== peerId) {
                        App.state.contacts[peerId].unread = (App.state.contacts[peerId].unread || 0) + 1;
                    }
                    
                    await Store.put('config', 'contacts', App.state.contacts);
                    UI.renderContactList();
                }
                
                // FIX #5: Always render if active chat matches, regardless of connection state
                if (App.state.activeChat === peerId) {
                    UI.renderMessage(msg);
                    const container = document.getElementById('messages-container');
                    setTimeout(() => {
                        if (container) {
                            container.scrollTop = container.scrollHeight;
                        }
                    }, 50);
                    
                    if (direction === 'in' && type === 'text') UI.showSmartReplies();
                }
            },
            exportIdentity: async () => {
                // ... (exportIdentity code remains the same) ...
            },
            deleteContact: async (peerId) => {
                if(confirm('Delete this contact and all chat history?')) {
                    // Clean up any blob URLs associated with this contact's messages
                    const msgs = await Store.getMessages(peerId);
                    msgs.forEach(msg => {
                        if (msg.content && msg.content.urlKey) {
                            URL.revokeObjectURL(msg.content.url);
                            Utils.blobRegistry.delete(msg.content.urlKey);
                        }
                    });
                    
                    delete App.state.contacts[peerId];
                    await Store.put('config', 'contacts', App.state.contacts);
                    await Store.deleteMessagesForPeer(peerId);
                    
                    if (App.state.activeChat === peerId) UI.closeChat();
                    UI.renderContactList();
                    UI.showToast('Contact deleted');
                }
            }
        };

        const UI = {
            typingTimeout: null, 
            selectionMode: false, 
            selectedMessages: new Set(), 
            currentAudio: null,
            toggleTheme: async () => {
                // ... (toggleTheme code remains the same) ...
            },
            toggleDebugMode: () => { 
                Network.CONFIG.DEBUG_MODE = !Network.CONFIG.DEBUG_MODE; 
                UI.showToast(Network.CONFIG.DEBUG_MODE ? 'Debug on' : 'Debug off'); 
                document.getElementById('debug-panel').classList.toggle('hidden', !Network.CONFIG.DEBUG_MODE); 
            },
            showTypingIndicator: (show) => { 
                document.getElementById('typing-indicator-container').classList.toggle('hidden', !show); 
            },
            showSmartReplies: () => {
                // ... (showSmartReplies code remains the same) ...
            },
            sendSmartReply: (text) => { 
                const input = document.getElementById('message-input'); 
                input.value = text; 
                Network.sendMessage(); 
            },
            saveDraft: async () => { 
                // ... (saveDraft code remains the same) ...
            },
            loadDraft: async (peerId) => { 
                // ... (loadDraft code remains the same) ...
            },
            clearDraft: async (peerId) => { 
                // ... (clearDraft code remains the same) ...
            },
            copyId: () => { 
                if (App.state.id) { 
                    navigator.clipboard.writeText(App.state.id); 
                    UI.showToast("ID copied!"); 
                } 
            },
            toggleAddContact: () => { 
                // ... (toggleAddContact code remains the same) ...
            },
            startScanner: async () => {
                // ... (startScanner code remains the same) ...
            },
            stopScanner: () => { 
                // ... (stopScanner code remains the same) ...
            },
            showQR: () => {
                // ... (showQR code remains the same) ...
            },
            closeQRModal: () => document.getElementById('qr-modal').classList.add('hidden'),
            updateNetworkStatus: (status) => {
                // ... (updateNetworkStatus code remains the same) ...
            },
            setNetworkButtons: (enabled) => { 
                // ... (setNetworkButtons code remains the same) ...
            },
            filterContacts: () => { 
                // ... (filterContacts code remains the same) ...
            },
            handleFileSelect: (e) => { 
                if (e.target.files[0]) { 
                    document.getElementById('file-preview-area').classList.remove('hidden'); 
                    document.getElementById('file-preview-name').innerText = e.target.files[0].name; 
                    UI.toggleSendIcon(); 
                } 
            },
            clearFile: () => { 
                document.getElementById('file-input').value = ''; 
                document.getElementById('file-preview-area').classList.add('hidden'); 
                UI.toggleSendIcon(); 
            },
            sendLocation: () => {
                // ... (sendLocation code remains the same) ...
            },
            handleMainAction: () => { 
                if (document.getElementById('message-input').value.trim() || document.getElementById('file-input').files.length > 0) 
                    Network.sendMessage(); 
                else Media.toggleRecordUI(); 
            },
            handleInputKey: (e) => { 
                if (e.key === 'Enter' && !e.shiftKey) { 
                    e.preventDefault(); 
                    Network.sendMessage(); 
                } else { 
                    UI.handleTypingAndDraft(); 
                } 
            },
            toggleSendIcon: () => {
                const hasText = document.getElementById('message-input').value.trim().length > 0;
                const hasFile = document.getElementById('file-input').files.length > 0;
                document.getElementById('icon-mic').classList.toggle('hidden', hasText || hasFile);
                document.getElementById('icon-send').classList.toggle('hidden', !hasText && !hasFile);
            },
            handleInputChange: () => { 
                UI.toggleSendIcon(); 
                UI.handleTypingAndDraft(); 
            },
            handleTypingAndDraft: () => { 
                Network.sendTyping(); 
                clearTimeout(UI.typingTimeout); 
                UI.typingTimeout = setTimeout(() => UI.saveDraft(), 500); 
            },
            toggleSearch: () => { 
                // ... (toggleSearch code remains the same) ...
            },
            searchMessages: () => {
                // ... (searchMessages code remains the same) ...
            },
            clearSearchHighlights: () => { 
                // ... (clearSearchHighlights code remains the same) ...
            },
            toggleChatMenu: () => { 
                // ... (toggleChatMenu code remains the same) ...
            },
            exportChat: () => { 
                // ... (exportChat code remains the same) ...
            },
            exportChatJSON: async () => { /* ... */ },
            exportChatText: async () => { /* ... */ },
            showMediaGallery: async () => {
                // ... (showMediaGallery code remains the same) ...
            },
            closeMediaGallery: () => document.getElementById('media-gallery-modal').classList.add('hidden'),
            clearChat: async () => { 
                if(confirm('Clear all messages?')) { 
                    await Store.deleteMessagesForPeer(App.state.activeChat); 
                    document.getElementById('messages-container').innerHTML = ''; 
                    document.getElementById('chat-menu').classList.add('hidden'); 
                } 
            },
            enterSelectionMode: () => { 
                // ... (enterSelectionMode code remains the same) ...
            },
            exitSelectionMode: () => { 
                // ... (exitSelectionMode code remains the same) ...
            },
            closeChat: () => { 
                document.getElementById('chat-area').classList.add('hidden'); 
                document.getElementById('sidebar-panel').classList.remove('hidden'); 
            },
            showSafetyNumber: async () => { 
                // ... (showSafetyNumber code remains the same) ...
            },
            updateHeaderStatus: (peerId, status) => { 
                if (App.state.activeChat === peerId) 
                    document.getElementById('chat-header-status').innerText = status; 
            },
            updateConnectionState: (peerId, state) => { 
                if (App.state.activeChat === peerId) 
                    UI.updateHeaderStatus(peerId, state === 'connected' ? 'Online' : 'Offline'); 
                UI.renderContactList(); 
            },
            loadChat: async (peerId) => {
                App.state.activeChat = peerId;
                const contact = App.state.contacts[peerId];
                if (!contact) return;
                
                // Hide progress bars
                const uploadProgress = document.getElementById('upload-progress');
                const downloadProgress = document.getElementById('download-progress');
                if (uploadProgress) uploadProgress.classList.add('hidden');
                if (downloadProgress) downloadProgress.classList.add('hidden');
                
                // Send read receipts
                const connObj = Network.connections[peerId];
                const messages = await Store.getMessages(peerId);
                
                if (connObj?.conn?.open) {
                    messages.forEach(msg => {
                        if (msg.direction === 'in' && msg.status !== 'read') {
                            msg.status = 'read';
                            Store.put('messages', null, msg);
                            connObj.conn.send({ type: 'receipt', msgId: msg.id, status: 'read' });
                        }
                    });
                }

                // Clear unread count
                if (contact.unread > 0) { 
                    contact.unread = 0; 
                    await Store.put('config', 'contacts', App.state.contacts); 
                    UI.renderContactList(); 
                }
                
                // Update UI
                document.getElementById('chat-empty-state').classList.add('hidden');
                document.getElementById('chat-interface').classList.remove('hidden');
                document.getElementById('chat-area').classList.remove('hidden');
                
                if (window.innerWidth < 768) 
                    document.getElementById('sidebar-panel').classList.add('hidden');
                
                document.getElementById('chat-header-name').innerText = contact.name;
                document.getElementById('chat-header-avatar').innerText = UI.generateAvatar(contact.name);
                
                // Render messages
                const container = document.getElementById('messages-container');
                container.innerHTML = '';
                messages.forEach(msg => UI.renderMessage(msg));
                
                setTimeout(() => {
                    if (container) {
                        container.scrollTop = container.scrollHeight;
                    }
                }, 100);
                
                await UI.loadDraft(peerId);
                document.getElementById('smart-replies-container').classList.add('hidden');
                
                // Highlight active chat
                document.querySelectorAll('#chat-list > div').forEach(el => el.classList.remove('bg-[#2a3942]'));
                document.querySelector(`#chat-list > div[data-peer="${peerId}"]`)?.classList.add('bg-[#2a3942]');
                
                if (typeof lucide !== 'undefined') lucide.createIcons();
            },
            showToast: (msg) => { 
                const t = document.createElement('div'); 
                t.className = 'fixed bottom-20 left-1/2 transform -translate-x-1/2 bg-[#202c33] text-white px-6 py-3 rounded-lg shadow-lg z-[150] animate-fade-in'; 
                t.innerText = msg; 
                document.body.appendChild(t); 
                setTimeout(() => t.remove(), 3000); 
            },
            renderMessage: async (msg) => {
                if (msg.deletedForMe) return;
                const container = document.getElementById('messages-container');
                const existing = document.getElementById(`msg-${msg.id}`); 
                if (existing) existing.remove();
                
                if (msg.deletedForEveryone) { 
                    container.innerHTML += `<div id="msg-${msg.id}" class="flex ${msg.direction==='out'?'justify-end':'justify-start'}"><div class="bg-[#2a3942] px-3 py-2 rounded-lg"><p class="text-xs text-[#8696a0] italic">ðŸš« Deleted</p></div></div>`; 
                    return; 
                }
                
                const div = document.createElement('div');
                div.id = `msg-${msg.id}`;
                div.className = `flex ${msg.direction === 'out' ? 'justify-end' : 'justify-start'} group relative`;
                
                // Context menu events
                div.addEventListener('contextmenu', (e) => { 
                    e.preventDefault(); 
                    UI.showMessageContextMenu(msg.id, e.clientX, e.clientY); 
                });
                let longPress;
                div.addEventListener('touchstart', (e) => { 
                    longPress = setTimeout(() => 
                        UI.showMessageContextMenu(msg.id, e.touches[0].clientX, e.touches[0].clientY), 500); 
                });
                div.addEventListener('touchend', () => clearTimeout(longPress));
                div.addEventListener('touchcancel', () => clearTimeout(longPress));

                let inner = '';
                const bubbleClass = msg.direction === 'out' ? 'msg-sent' : 'msg-received';
                const statusHtml = msg.direction === 'out' ? Utils.getStatusHtml(msg.status) : '';
                const timestamp = new Date(msg.timestamp).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'});
                
                if (msg.type === 'text') {
                    inner = `<div class="bubble-constraint"><div class="${bubbleClass} px-3 py-2 text-sm relative"><div>${Utils.linkify(msg.content)}</div><div class="text-[10px] text-right mt-1 opacity-60 flex items-center justify-end">${timestamp} ${statusHtml}</div></div><div id="reactions-${msg.id}" class="message-reactions"></div></div>`;
                } else if (msg.type === 'location') {
                    const locUrl = msg.content.url || `https://www.openstreetmap.org/?mlat=${msg.content.lat}&mlon=${msg.content.lon}#map=15/${msg.content.lat}/${msg.content.lon}`;
                    inner = `<div class="bubble-constraint"><div class="${bubbleClass} px-3 py-2 text-sm relative"><div class="flex items-center gap-2"><i data-lucide="map-pin" class="w-5 h-5 text-[#00a884]"></i><a href="${locUrl}" target="_blank" class="text-blue-400 hover:underline">View Location</a></div><div class="text-[10px] text-right mt-1 opacity-60 flex items-center justify-end">${timestamp} ${statusHtml}</div></div><div id="reactions-${msg.id}" class="message-reactions"></div></div>`;
                } else if (msg.type === 'voice') {
                    // Use existing URL or create one if needed
                    let url = msg.content.url;
                    if (!url && msg.content.blob) {
                        const urlKey = `voice-${msg.id}`;
                        url = Utils.addBlob(urlKey, URL.createObjectURL(msg.content.blob));
                        // Update message with URL
                        msg.content.url = url;
                        msg.content.urlKey = urlKey;
                        Store.put('messages', null, msg);
                    }
                    
                    if (url) {
                        inner = `<div class="bubble-constraint"><div class="${bubbleClass} px-3 py-2 relative"><div class="audio-card"><button class="audio-play-btn" onclick="UI.playAudio(this, '${url}')"><i data-lucide="play" class="w-4 h-4"></i></button><div class="waveform">${Array(15).fill('<div class="bar"></div>').join('')}</div></div><div class="text-[10px] text-right mt-1 opacity-60 flex items-center justify-end">${timestamp} ${statusHtml}</div></div><div id="reactions-${msg.id}" class="message-reactions"></div></div>`;
                    } else {
                        inner = `<div class="bubble-constraint"><div class="${bubbleClass} px-3 py-2 text-sm relative"><div class="text-[#8696a0] italic">ðŸŽ¤ Voice message</div><div class="text-[10px] text-right mt-1 opacity-60 flex items-center justify-end">${timestamp} ${statusHtml}</div></div><div id="reactions-${msg.id}" class="message-reactions"></div></div>`;
                    }
                } else if (msg.type === 'file') {
                    // FIX #1: Use enhanced detection for image/video files
                    const mime = Utils.detectMimeType(msg.content.name, msg.content.mime);
                    const fileName = msg.content.name || 'File';
                    const fileSize = msg.content.size ? Utils.formatBytes(msg.content.size) : '';
                    
                    // FIX #1: Better image detection
                    const isImage = Utils.isImageFile(fileName, mime);
                    const isVideo = mime.startsWith('video/');
                    
                    // FIX #2: Use stored URL or create one
                    let url = msg.content.url;
                    if (!url && msg.content.blob) {
                        const urlKey = `file-${msg.id}`;
                        url = Utils.addBlob(urlKey, URL.createObjectURL(msg.content.blob));
                        // Update message with URL
                        msg.content.url = url;
                        msg.content.urlKey = urlKey;
                        Store.put('messages', null, msg);
                    }
                    
                    if (isImage && url) {
                        // WhatsApp-style image display
                        inner = `<div class="bubble-constraint max-w-xs"><div class="${bubbleClass} p-1 relative overflow-hidden rounded-lg"><img src="${url}" class="w-full h-auto max-h-80 object-cover rounded cursor-pointer" onclick="window.open('${url}', '_blank')" loading="lazy"><div class="absolute bottom-0 right-0 left-0 bg-gradient-to-t from-black/60 to-transparent p-2"><div class="text-white text-xs">${Utils.escapeHTML(fileName)}</div></div><div class="text-[10px] text-right mt-1 px-2 opacity-60 flex items-center justify-end text-white">${timestamp} ${statusHtml}</div></div><div id="reactions-${msg.id}" class="message-reactions"></div></div>`;
                    } else if (isVideo && url) {
                        // WhatsApp-style video display
                        inner = `<div class="bubble-constraint max-w-xs"><div class="${bubbleClass} p-1 relative overflow-hidden rounded-lg"><video src="${url}" class="w-full h-auto max-h-80 object-cover rounded" controls poster="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='300' viewBox='0 0 400 300'%3E%3Crect width='400' height='300' fill='%23202c33'/%3E%3Cpath d='M160,120 v60 l40-30 z' fill='%23ffffff'/%3E%3C/svg%3E"></video><div class="absolute bottom-0 right-0 left-0 bg-gradient-to-t from-black/60 to-transparent p-2"><div class="text-white text-xs">${Utils.escapeHTML(fileName)}</div></div><div class="text-[10px] text-right mt-1 px-2 opacity-60 flex items-center justify-end text-white">${timestamp} ${statusHtml}</div></div><div id="reactions-${msg.id}" class="message-reactions"></div></div>`;
                    } else {
                        // File with download button (WhatsApp-style)
                        const fileIcon = Utils.getFileIcon(mime, fileName);
                        const downloadBtn = url ? 
                            `<a href="${url}" download="${fileName}" class="text-[#00a884] hover:underline text-xs flex items-center gap-1 mt-1 px-3 py-1 bg-black/20 rounded-lg"><i data-lucide="download" class="w-3 h-3"></i>Download (${fileSize})</a>` : 
                            '<div class="text-xs text-[#8696a0] mt-1 px-3 py-1 bg-black/20 rounded-lg">Downloading...</div>';
                        
                        inner = `<div class="bubble-constraint"><div class="${bubbleClass} px-3 py-2 relative"><div class="file-card-inner backdrop-blur-none">${fileIcon}<div class="flex-1 min-w-0"><div class="font-medium text-sm truncate">${Utils.escapeHTML(fileName)}</div>${downloadBtn}</div></div><div class="text-[10px] text-right mt-1 opacity-60 flex items-center justify-end">${timestamp} ${statusHtml}</div></div><div id="reactions-${msg.id}" class="message-reactions"></div></div>`;
                    }
                } else if (msg.type === 'file-receiving') {
                    // Placeholder for incoming file
                    const mime = Utils.detectMimeType(msg.content.name, msg.content.mime);
                    const fileName = msg.content.name || 'File';
                    const fileIcon = Utils.getFileIcon(mime, fileName);
                    
                    inner = `<div class="bubble-constraint"><div class="${bubbleClass} px-3 py-2 relative"><div class="file-card-inner backdrop-blur-none">${fileIcon}<div class="flex-1 min-w-0"><div class="font-medium text-sm truncate">${Utils.escapeHTML(fileName)}</div><div class="text-xs text-[#8696a0] mt-1 px-3 py-1 bg-black/20 rounded-lg"><div class="inline-block h-1 w-4 bg-[#00a884] rounded-full animate-pulse mr-2"></div>Receiving...</div></div></div><div class="text-[10px] text-right mt-1 opacity-60 flex items-center justify-end">${timestamp}</div></div><div id="reactions-${msg.id}" class="message-reactions"></div></div>`;
                }
                
                div.innerHTML = inner;
                container.appendChild(div);
                
                if (typeof lucide !== 'undefined') lucide.createIcons();
                await UI.updateReactions(msg.id);
            },
            updateMessageTick: (msgId, status) => { 
                const el = document.querySelector(`#msg-${msgId} .status-container`); 
                if(el) el.innerHTML = Utils.getStatusHtml(status); 
            },
            showMessageContextMenu: (msgId, x, y) => {
                UI.selectedMessageId = msgId;
                const menu = document.getElementById('message-context-menu');
                menu.classList.remove('hidden');
                
                const menuWidth = 200, menuHeight = 300;
                const screenW = window.innerWidth, screenH = window.innerHeight;
                
                let left = x, top = y;
                if (x + menuWidth > screenW) left = screenW - menuWidth - 10;
                if (y + menuHeight > screenH) top = screenH - menuHeight - 10;
                
                menu.style.left = left + 'px';
                menu.style.top = top + 'px';
                
                setTimeout(() => { 
                    document.addEventListener('click', UI.closeMessageContextMenu, { once: true }); 
                }, 100);
            },
            closeMessageContextMenu: () => { 
                document.getElementById('message-context-menu').classList.add('hidden'); 
                UI.selectedMessageId = null; 
            },
            toggleReactionPicker: (msgId) => { 
                UI.selectedMessageId = msgId; 
                UI.reactToMessage(); 
            },
            reactToMessage: () => { /* ... */ },
            updateReactions: async (msgId) => {
                // ... (updateReactions code remains the same) ...
            },
            renderContactList: () => {
                const container = document.getElementById('chat-list'); 
                container.innerHTML = '';
                const sorted = Object.entries(App.state.contacts).sort((a, b) => (b[1].lastSeen || 0) - (a[1].lastSeen || 0));
                
                sorted.forEach(([peerId, contact]) => {
                    const div = document.createElement('div');
                    div.className = 'p-3 hover:bg-[#2a3942] cursor-pointer border-b border-[#2a3942] flex items-center gap-3';
                    div.setAttribute('data-peer', peerId);
                    div.onclick = () => UI.loadChat(peerId);
                    
                    // Connection status indicator
                    const connObj = Network.connections[peerId];
                    const isOnline = connObj?.handshakeComplete;
                    const statusColor = isOnline ? '#00a884' : '#8696a0';
                    const statusText = isOnline ? 'Online' : 'Offline';
                    
                    div.innerHTML = `
                        <div class="relative">
                            <div class="w-12 h-12 rounded-full bg-gradient-to-br from-[#00a884] to-[#008f6f] flex items-center justify-center text-white font-bold flex-shrink-0">
                                ${UI.generateAvatar(contact.name)}
                            </div>
                            <div class="absolute -bottom-1 -right-1 w-4 h-4 rounded-full border-2 border-[#111b21]" style="background-color: ${statusColor};"></div>
                        </div>
                        <div class="flex-1 min-w-0">
                            <div class="font-semibold text-sm text-[#e9edef] truncate flex items-center gap-2">
                                ${Utils.escapeHTML(contact.name)}
                                <span class="text-[10px] px-2 py-0.5 rounded-full" style="background-color: ${statusColor}20; color: ${statusColor};">${statusText}</span>
                            </div>
                            <div class="text-xs text-[#8696a0] truncate">
                                ${contact.draft?'<span class="text-red-400">Draft:</span> ':''}${contact.lastMessage||'No messages'}
                            </div>
                        </div>
                        ${contact.unread>0?`<div class="unread-badge">${contact.unread}</div>`:''}
                    `;
                    
                    // Delete on long press
                    let timer;
                    div.addEventListener('touchstart', () => {
                        timer = setTimeout(() => {
                            if (confirm(`Delete contact ${contact.name}?`)) {
                                App.deleteContact(peerId);
                            }
                        }, 1000);
                    });
                    div.addEventListener('touchend', () => clearTimeout(timer));
                    div.addEventListener('touchcancel', () => clearTimeout(timer));
                    
                    container.appendChild(div);
                });
                
                if (sorted.length === 0) 
                    container.innerHTML = '<div class="p-4 text-center text-[#8696a0] text-sm">No contacts yet</div>';
            },
            generateAvatar: (name) => { 
                if (!name) return '?'; 
                const words = name.trim().split(/\s+/); 
                return (words.length >= 2 ? words[0][0] + words[1][0] : name.substring(0, 2)).toUpperCase(); 
            },
            stopCurrentAudio: () => {
                if (UI.currentAudio) {
                    UI.currentAudio.pause();
                    UI.currentAudio = null;
                }
            },
            playAudio: (btn, url) => {
                UI.stopCurrentAudio();
                
                const audio = new Audio(url);
                const waveform = btn.parentElement;
                const icon = btn.querySelector('i');
                
                const resetUI = () => {
                    icon.setAttribute('data-lucide', 'play');
                    waveform.classList.remove('playing');
                    if (typeof lucide !== 'undefined') lucide.createIcons();
                    if (UI.currentAudio === audio) UI.currentAudio = null;
                };
                
                audio.onplay = () => {
                    icon.setAttribute('data-lucide', 'pause');
                    waveform.classList.add('playing');
                    if (typeof lucide !== 'undefined') lucide.createIcons();
                };
                
                audio.onpause = resetUI;
                audio.onended = resetUI;
                
                UI.currentAudio = audio;
                audio.play().catch((err) => {
                    console.warn('Audio playback failed:', err);
                    resetUI();
                    UI.showToast('Cannot play audio');
                });
            }
        };

        const Media = {
            // ... (Media code remains the same) ...
        };

        window.addEventListener('load', App.init);
        window.addEventListener('beforeunload', () => { 
            Utils.revokeBlobs(); 
            if (Media.localStream) Media.localStream.getTracks().forEach(t => t.stop()); 
            if (Media.scanner) Media.scanner.stop().catch(()=>{}); 
            if (Network.peer) { 
                Network.stopPingMonitor(); 
                Network.peer.destroy(); 
            } 
        });
        
        // Auto-reconnection on page visibility
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && App.state.id) {
                setTimeout(() => {
                    if (Network.peer && Network.peer.disconnected) {
                        Network.peer.reconnect();
                    }
                }, 500);
            }
        });
    </script>
</body>
</html>
